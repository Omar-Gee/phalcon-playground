
This file handles three things:

* Registration of component autoloaders
* Configuring Services and registering them with the Dependency Injection context
* Resolving the application’s HTTP requests

```
<?php

use Phalcon\Loader;
use Phalcon\Mvc\View;
use Phalcon\Mvc\View\Engine\Volt;
use Phalcon\Mvc\Application;
use Phalcon\Di\FactoryDefault;
use Phalcon\Mvc\Url as UrlProvider;
use Phalcon\Db\Adapter\Pdo\Mysql as DbAdapter;


// Define some absolute path constants to aid in locating resources
define('BASE_PATH', dirname(__DIR__));
define('APP_PATH', BASE_PATH . '/app');
```
>Autoloaders leverage a PSR-4 compliant file loader running through the Phalcon. Common things that should be added to the autoloader are your controllers and models. You can register directories which will search for files within the application’s namespace.
```
// Create new autoloader instance
$loader = new Loader();

// register some directories
$loader->registerDirs(
    [
        APP_PATH . '/controllers/',
        APP_PATH . '/models/',
    ]
);
// register autoloader
$loader->register();

```
>Since Phalcon is loosely coupled, services are registered with the frameworks Dependency Manager so they can be injected automatically to components and services wrapped in the IoC container. Frequently you will encounter the term DI which stands for Dependency Injection. Dependency Injection and Inversion of Control(IoC) may sound like a complex feature but in Phalcon their use is very simple and practical. Phalcon’s IoC container consists of the following concepts:
>* Service Container: a “bag” where we globally store the services that our application needs to function.
>* Service or Component: Data processing object which will be injected into components
>
>Each time the framework requires a component or service, it will ask the container using an agreed upon name for the service. Don’t forget to include Phalcon\Di with setting up the service container.

```
// Create a DI
$di = new FactoryDefault();
```
>In the next part, we register the “view” service indicating the directory where the framework will find the views files. As the views do not correspond to classes, they cannot be charged with an autoloader.
```

// Setup the view component
$di->set(
    'view',
                function () {
        $view = new View();
        $view->setViewsDir(APP_PATH . '/views/');
        return $view;
    }
);
```

>Next, we register a base URI so that all URIs generated by Phalcon match the application’s base path of “/”. This will become important later on in this tutorial when we use the class Phalcon\Tag to generate a hyperlink.
```
// Setup a base URI
$di->set(
    'url',
    function () {
        $url = new UrlProvider();
        $url->setBaseUri('/');
        return $url;
    }
);
```
>In order to use a database connection and subsequently access data through our models, we need to specify it in our bootstrap process. A database connection is just another service that our application has that can be used for several components:
```
$di->set('db', function(){
    return new DbAdapter([
        'host' => '127.0.0.1',
        'username' => 'omargee',
        'password' => 'hosIntraAssignment',
        'dbname' => 'basic'
    ]);
  }
);

```
>In the last part of this file, we find Phalcon\Mvc\Application. Its purpose is to initialize the request environment, route the incoming request, and then dispatch any discovered actions; it aggregates any responses and returns them when the process is complete.
```
$application = new Application($di);
// Handle the request
try {

    $response = $application->handle();
    $response->send();
} catch (\Exception $e) {
    echo 'Exception: ', $e->getMessage();
}
```